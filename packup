#!/usr/bin/bash
#
#  Copyright 2016 Matteo Alessio Carrara <sw.matteoac@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#

set -e
source /usr/local/lib/bash_colors


# TODO Reinserire hash
# TODO Controlli integrità periodici / hash files
# TODO I backup dovrebbero essere read only


function check_env_var()
{
	# Devono essere definite queste variabili d'ambiente
	#
	# PACKUP_ROOT	dove vengono salvati i backup (e solo quelli!!)
	# PACKUP_FILES	files da copiare

	if [[ -z $PACKUP_ROOT ]] || [[ -z $PACKUP_FILES ]]; then
		clr_red "Le variabili d'ambiente PACKUP_ROOT e PACKUP_FILES devono essere definite"
		exit 1
	fi
}


function execute_hooks()
{
	if [[ $# -ne 1 ]]; then
		clr_red -n "$FUNCNAME: $LINENO: "; echo "parametri scorretti"
		exit 1
	else
		local HOOKS_DIR=$1
	fi

	if [[ -d $HOOKS_DIR ]]; then
		for f in $(ls $HOOKS_DIR); do
			. $HOOKS_DIR/$f
		done
	else
		warn "La directory degli hooks è inesistente ($HOOKS_DIR)"
	fi
}


function find_old_backups()
{
	find $PACKUP_ROOT -maxdepth 1 -type d | sort 
}


function main()
{
	check_env_var

	if [[ ! -d $PACKUP_ROOT ]]; then
		clr_red "La directory \"$PACKUP_ROOT\" non è esistente"
		exit 1
	fi
	
	
	local PRE_HOOKS_DIR=~/packup/pre
	local POST_HOOKS_DIR=~/packup/post
	
	local DEST="$PACKUP_ROOT/$(date --iso-8601=seconds)"
	local PREV_BKUP="$(find_old_backups | tail -n 1)"
	local HASH_FILE="$PACKUP_ROOT/hash"
	
	local OPT_CMD=$([[ -n $PREV_BKUP ]] && echo "--link-dest=$PREV_BKUP" || echo -n "")
	local RSYNC_FLAGS="--archive --relative --hard-links --human-readable --info=misc2,name,skip,stats,symsafe $OPT_CMD"

	
	[[ -n $PREV_BKUP ]] && inf "Individuato backup precedente \($PREV_BKUP\)"

	inf "Esecuzione degli script di pre-backup..."
	execute_hooks $PRE_HOOKS_DIR


	inf "Copia dei file..."
	mkdir $DEST
	rsync $RSYNC_FLAGS ${PACKUP_FILES[@]} $DEST

	
	inf "Calcolo degli hash..."
	# I file con un solo hardlink non sono gli stessi dei vecchi backup
	find $DEST -type f -links 1 -printf '"%p"\n' | xargs md5sum >> $HASH_FILE
	# Se i file con più di un hardlink sono esterni a questo backup, allora l'hash
	# è già stato calcolato nei vecchi backup
	readarray -t a < <(find $DEST -type f -not -links 1)
	for f in $a; do
		need_hash="true"
		readarray -t b < <(find $PACKUP_ROOT -samefile "$f")
		for ff in $b; do
			if [[ ! $(realpath "$ff") == $(realpath $DEST)* ]]; then
				need_hash="false"
				break
			fi
		done
		[[ $need_hash == "true" ]] && md5sum "$f" >> $HASH_FILE
	done
	
	inf "Esecuzione degli script di post-backup.."
	execute_hooks $POST_HOOKS_DIR
	
	inf "Backup terminato"
}


main
